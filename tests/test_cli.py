"""Test cli/*.py."""

import io
import os
import re
import tempfile
from argparse import Namespace
from pathlib import Path
from typing import Optional, Tuple
from uuid import UUID, uuid4

import pytest
import requests
from conftest import capture_logs

from mse_cli.api.types import SSLCertificateOrigin
from mse_cli.command.context import run as run_context
from mse_cli.command.deploy import run as run_deploy
from mse_cli.command.list_all import run as run_list
from mse_cli.command.login import run as run_login
from mse_cli.command.logs import run as run_logs
from mse_cli.command.scaffold import run as run_scaffold
from mse_cli.command.status import run as run_status
from mse_cli.command.stop import run as run_stop
from mse_cli.command.verify import run as run_verify
from mse_cli.conf.app import AppConf, SSLConf
from mse_cli.conf.context import Context


def _test_verify(
    f,
    domain_name: str,
    fingerprint: str,
    context: Optional[Path],
    code: Optional[Path],
    is_self_signed: bool,
) -> Optional[Path]:
    """Test the verify subcommand."""
    run_verify(
        Namespace(
            **{
                "fingerprint": fingerprint,
                "context": context,
                "code": code,
                "domain_name": domain_name,
            }
        )
    )

    output = capture_logs(f)

    if not is_self_signed:
        assert "The application is not using a certificate generated by MSE" in output
    else:
        return re.search(
            "The verified certificate has been saved at: (.+)", output
        ).group(1)

    return None


def _test_scaffold() -> Path:
    """ "Test the scaffold subcommand."""
    # Generate a random unique app name
    unique_name = str(uuid4())

    # Go into a unique tmp directory
    path = Path(tempfile.mkdtemp())
    os.chdir(path)

    # Run scaffold
    run_scaffold(Namespace(**{"app_name": unique_name}))

    # Check creation of files
    conf = path / unique_name / "mse.toml"
    assert conf.exists()
    assert (path / unique_name / "mse_src").exists()

    # The viability (is that runnable?) of the code will be tested later
    return conf


def _test_deploy(
    f: io.StringIO, conf: Path, untrusted_ssl: bool
) -> Tuple[UUID, str, str]:
    """Test the deploy subcommand."""
    run_deploy(
        Namespace(
            **{
                "path": conf,
                "y": False,
                "no_verify": False,
                "untrusted_ssl": untrusted_ssl,
            }
        )
    )

    output = capture_logs(f)

    try:
        app_id = re.search("mse logs ([a-z0-9-]+)", output).group(1)

        domain_name = re.search("ready to be used on https://(.+) until", output).group(
            1
        )

        mr_enclave = re.search("The code fingerprint is ([a-z0-9]+)", output).group(1)

    except AttributeError:
        print(output)
        assert False

    return UUID(app_id), domain_name, mr_enclave


def _test_context(f: io.StringIO, app_id: UUID) -> Context:
    """Test the context subcommand."""
    # Check the context directory
    assert Context.get_context_filepath(app_id, create=False).exists()
    assert (
        Context.get_dirpath(app_id, False) / Context.get_tar_code_filename()
    ).exists()

    # Check the context subcommand (listing)
    run_context(
        Namespace(**{"list": True, "remove": False, "purge": False, "export": None})
    )

    output = capture_logs(f)
    assert str(app_id) in output

    # Check the context subcommand (exporting)
    run_context(
        Namespace(**{"list": False, "remove": False, "purge": False, "export": app_id})
    )

    _ = capture_logs(f)
    context_path = Path(f"{app_id}.toml")
    assert context_path.exists()
    return Context.from_toml(context_path)


def _test_status(f: io.StringIO, app_id: UUID, expecting_status: str):
    """Test status subcommand."""
    run_status(Namespace(**{"app_id": app_id}))

    output = capture_logs(f)
    assert expecting_status in output


def _test_login(f: io.StringIO):
    """Test status subcommand."""
    run_login(Namespace(**{"whoami": True}))

    output = capture_logs(f)
    assert "You are currently logged in" in output


def _test_logs(f: io.StringIO, app_id: UUID, expecting_output: str):
    """Test logs subcommand."""
    run_logs(Namespace(**{"app_id": app_id}))

    output = capture_logs(f)
    assert expecting_output in output


def _test_list(f: io.StringIO, project_name: str, app_id: UUID, expecting_result: bool):
    """Test list subcommand."""
    run_list(Namespace(**{"project_name": project_name, "all": False}))

    output = capture_logs(f)
    assert (str(app_id) in output) == expecting_result


def _test_mse_cli(
    f: io.StringIO, ssl_certificate_origin: SSLCertificateOrigin, untrusted_ssl=bool
):
    """Test a complete deployment flow."""
    # Test the login subcommand
    _test_login(f)

    # Test the scaffold subcommand
    conf = _test_scaffold()
    app_conf = AppConf.from_toml(conf)

    if ssl_certificate_origin == SSLCertificateOrigin.Owner:
        assert not app_conf.ssl

        path = Path(tempfile.mkdtemp())
        cert_path = path / "cert.pem"
        cert_path.write_text(os.getenv("MSE_TEST_PUBLIC_KEY"))
        key_path = path / "key.path"
        key_path.write_text(os.getenv("MSE_TEST_PRIVATE_KEY"))

        app_conf.ssl = SSLConf(
            domain_name=f"{app_conf.name}.{os.getenv('MSE_TEST_DOMAIN_NAME')}",
            private_key=key_path,
            certificate=cert_path,
        )
        app_conf.save(conf.parent)
    else:
        assert not app_conf.ssl

    # Test the deploy subcommand
    (app_id, domain_name, mr_enclave) = _test_deploy(f, conf, untrusted_ssl)

    # Test the context subcommand
    context = _test_context(f, app_id)

    # Check the ssl type
    if ssl_certificate_origin == SSLCertificateOrigin.Owner and untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Operator
        assert not context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Owner and not untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Owner
        assert context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Self and untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Operator
        assert not context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Self and not untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self
        assert not context.config.ssl_app_certificate

    # Test the verify subcommand
    # Skip MR Enclave computation
    _test_verify(
        f,
        domain_name,
        False,
        None,
        None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
    )
    # Give the MR Enclave
    _test_verify(
        f,
        domain_name,
        mr_enclave,
        None,
        None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
    )
    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        # Give a bad MR Enclave
        with pytest.raises(Exception):
            run_verify(
                Namespace(
                    **{
                        "fingerprint": "00000000",
                        "context": None,
                        "code": None,
                        "domain_name": domain_name,
                    }
                )
            )
        # Compute the MR Enclave (bad code)
        with pytest.raises(Exception):
            run_verify(
                Namespace(
                    **{
                        "fingerprint": None,
                        "context": Context.get_context_filepath(app_id, False),
                        "code": Path("."),
                        "domain_name": domain_name,
                    }
                )
            )
    # Compute the MR Enclave
    cert_path = _test_verify(
        f,
        domain_name,
        False,
        Context.get_context_filepath(app_id, False),
        app_conf.code.location,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
    )

    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        assert cert_path is not None
        # Check the url is working with the proper certificate
        r = requests.get(url=f"https://{domain_name}/", verify=cert_path, timeout=10)
    else:
        r = requests.get(url=f"https://{domain_name}/", timeout=10)

    assert r.ok
    assert r.text == "Hello world"

    # Test status subcommand
    _test_status(f, app_id, "running")
    _test_logs(f, app_id, 'GET / HTTP/1.1" 200')

    # Test list subcommand
    _test_list(f, app_conf.project, app_id, True)

    # Test stop app
    run_stop(Namespace(**{"app_id": [app_id]}))

    # Test status subcommand
    _test_status(f, app_id, "stopped")
    _test_logs(f, app_id, 'GET / HTTP/1.1" 200')

    # Test list subcommand
    _test_list(f, app_conf.project, app_id, False)

    f.truncate(0)

    # Check the context subcommand
    run_context(
        Namespace(**{"list": True, "remove": False, "purge": False, "export": None})
    )

    output = capture_logs(f)
    assert str(app_id) not in output
    assert not Context.get_dirpath(app_id, False).exists()


@pytest.mark.slow
def test_mse_cli_self_signed(cmd_log):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Self, False)


@pytest.mark.slow
def test_mse_cli_with_ssl(cmd_log):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Owner, False)


@pytest.mark.slow
def test_mse_cli_self_signed_untrusted(cmd_log):
    """Test a complete deployment flow for untrusted ssl."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Self, True)


@pytest.mark.slow
def test_mse_cli_with_ssl_untrusted(cmd_log):
    """Test a complete deployment flow for untrusted ssl."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Owner, True)
