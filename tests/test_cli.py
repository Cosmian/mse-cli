"""Test cli/*.py."""

from argparse import Namespace
from pathlib import Path
import tempfile
from typing import Optional, Tuple
import os

import pytest
import requests

from mse_cli.api.types import SSLCertificateOrigin
from mse_cli.command.deploy import run as run_deploy
from mse_cli.command.verify import run as run_verify
from mse_cli.command.status import run as run_status
from mse_cli.command.list_all import run as run_list
from mse_cli.command.stop import run as run_stop
from mse_cli.command.remove import run as run_remove
from mse_cli.command.scaffold import run as run_scaffold
from mse_cli.command.context import run as run_context

from mse_cli.conf.app import AppConf, SSLConf

import re
import io
from uuid import UUID, uuid4
from mse_cli.conf.context import Context
from conftest import capture_logs


def _test_verify(f, domain_name: str, skip_fingerprint: bool, fingerprint: str,
                 context: Optional[Path], code: Optional[Path],
                 is_self_signed: bool) -> Optional[Path]:
    """Test the verify subcommand."""
    run_verify(
        Namespace(
            **{
                "skip_fingerprint": skip_fingerprint,
                "fingerprint": fingerprint,
                "context": context,
                "code": code,
                "domain_name": domain_name
            }))

    output = capture_logs(f)

    if not is_self_signed:
        assert "The application is not using a certificate generated by mse." in output
    else:
        return re.search('The verified certificate has been saved at: (.+)',
                         output).group(1)

    return None


def _test_scaffold() -> Path:
    """"Test the scaffold subcommand."""
    # Generate a random unique app name
    unique_name = str(uuid4())

    # Go into a unique tmp directory
    path = Path(tempfile.mkdtemp())
    os.chdir(path)

    # Run scaffold
    run_scaffold(Namespace(**{"app_name": unique_name}))

    # Check creation of files
    conf = path / unique_name / "mse.toml"
    assert conf.exists()
    assert (path / unique_name / "code").exists()

    # The viability (is that runnable?) of the code will be tested later
    return conf


def _test_deploy(f: io.StringIO, conf: Path) -> Tuple[UUID, str, str]:
    """Test the deploy subcommand."""
    run_deploy(Namespace(**{"path": conf, "force": False}))

    output = capture_logs(f)

    try:
        app_uuid = re.search('App ([a-z0-9-]+) creating for', output).group(1)

        domain_name = re.search(
            'It\'s now ready to be used on https://(.+) until', output).group(1)

        mr_enclave = re.search('The code fingerprint is ([a-z0-9]+)',
                               output).group(1)

    except AttributeError:
        print(output)
        assert False

    return UUID(app_uuid), domain_name, mr_enclave


def _test_context(f: io.StringIO, app_uuid: UUID) -> Context:
    """Test the context subcommand."""
    # Check the context directory
    assert Context.get_context_filepath(app_uuid, create=False).exists()
    assert (Context.get_dirpath(app_uuid, False) /
            Context.get_tar_code_filename()).exists()

    # Check the context subcommand (listing)
    run_context(
        Namespace(**{
            "list": True,
            "remove": False,
            "purge": False,
            "export": None
        }))

    output = capture_logs(f)
    assert str(app_uuid) in output

    # Check the context subcommand (exporting)
    run_context(
        Namespace(**{
            "list": False,
            "remove": False,
            "purge": False,
            "export": app_uuid
        }))

    _ = capture_logs(f)
    context_path = Path(f"{app_uuid}.toml")
    assert context_path.exists()
    return Context.from_toml(context_path)


def _test_status(f: io.StringIO, app_uuid: UUID, expecting_status: str):
    """Test status subcommand."""
    run_status(Namespace(**{"app_uuid": app_uuid, "log": True}))

    output = capture_logs(f)
    assert expecting_status in output


def _test_list(f: io.StringIO, project_name: str, app_uuid: UUID,
               expecting_result: bool):
    """Test list subcommand."""
    run_list(Namespace(**{"project_name": project_name}))

    output = capture_logs(f)
    assert (str(app_uuid) in output) == expecting_result


def _test_mse_cli(f: io.StringIO, ssl_certificate_origin: SSLCertificateOrigin):
    """Test a complete deployment flow."""
    # Test the scaffold subcommand
    conf = _test_scaffold()
    app_conf = AppConf.from_toml(conf)
    if ssl_certificate_origin == SSLCertificateOrigin.Owner:
        assert not app_conf.ssl
        app_conf.ssl = SSLConf(
            domain_name=f"{app_conf.name}.{os.getenv('MSE_TEST_DOMAIN_NAME')}",
            private_key=os.getenv("MSE_TEST_PRIVATE_KEY"),
            certificate=os.getenv("MSE_TEST_PUBLIC_KEY"))
        app_conf.save(conf.parent)
    elif ssl_certificate_origin == SSLCertificateOrigin.Operator:
        assert not app_conf.dev
        app_conf.dev = True
        app_conf.save(conf.parent)
    else:
        assert not app_conf.ssl
        assert not app_conf.dev

    # Test the deploy subcommand
    (app_uuid, domain_name, mr_enclave) = _test_deploy(f, conf)

    # Test the context subcommand
    context = _test_context(f, app_uuid)
    assert context.instance.ssl_certificate_origin == ssl_certificate_origin

    # Test the verify subcommand
    # Skip MR Enclave computation
    _test_verify(
        f, domain_name, True, False, None, None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self)
    # Give the MR Enclave
    _test_verify(
        f, domain_name, False, mr_enclave, None, None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self)
    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        # Give a bad MR Enclave
        with pytest.raises(Exception):
            run_verify(
                Namespace(
                    **{
                        "skip_fingerprint": False,
                        "fingerprint": "00000000",
                        "context": None,
                        "code": None,
                        "domain_name": domain_name
                    }))
        # Compute the MR Enclave (bad code)
        with pytest.raises(Exception):
            run_verify(
                Namespace(
                    **{
                        "skip_fingerprint":
                            False,
                        "fingerprint":
                            None,
                        "context":
                            Context.get_context_filepath(app_uuid, False),
                        "code":
                            Path("."),
                        "domain_name":
                            domain_name
                    }))
    # Compute the MR Enclave
    cert_path = _test_verify(
        f, domain_name, False, False,
        Context.get_context_filepath(app_uuid, False), app_conf.code.location,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self)

    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        assert cert_path is not None
        # Check the url is working with the proper certificate
        r = requests.get(
            url=f"https://{domain_name}{app_conf.code.health_check_endpoint}",
            verify=cert_path,
            timeout=10)
    else:
        r = requests.get(
            url=f"https://{domain_name}{app_conf.code.health_check_endpoint}",
            timeout=10)

    assert r.ok
    assert r.text == "Hello world"

    # Test status subcommand
    _test_status(f, app_uuid, "running")

    # Test list subcommand
    _test_list(f, app_conf.project, app_uuid, True)

    # Test stop app
    run_stop(Namespace(**{"app_uuid": app_uuid}))

    # Test status subcommand
    _test_status(f, app_uuid, "stopped")

    # Test list subcommand
    _test_list(f, app_conf.project, app_uuid, False)

    # Test remove app
    run_remove(Namespace(**{"app_uuid": app_uuid}))

    # Test status subcommand
    with pytest.raises(Exception):
        _test_status(f, app_uuid, "removed")

    f.truncate(0)

    # Check the context subcommand
    run_context(
        Namespace(**{
            "list": True,
            "remove": False,
            "purge": False,
            "export": None
        }))

    output = capture_logs(f)
    assert str(app_uuid) not in output
    assert not Context.get_dirpath(app_uuid, False).exists()


@pytest.mark.slow
def test_mse_cli_self_signed(cmd_log):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Self)


@pytest.mark.slow
def test_mse_cli_with_ssl(cmd_log):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Owner)


@pytest.mark.slow
def test_mse_cli_dev_mode(cmd_log):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(cmd_log, SSLCertificateOrigin.Operator)
