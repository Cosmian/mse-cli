"""Test command/*.py."""

import io
import os
import re
from argparse import Namespace
from pathlib import Path
import tempfile
from typing import Optional, Tuple
from uuid import UUID, uuid4

import pytest
import requests
from conftest import capture_logs

from mse_cli.cloud.api.types import SSLCertificateOrigin
from mse_cli.cloud.command.context import run as run_context
from mse_cli.cloud.command.deploy import run as run_deploy
from mse_cli.cloud.command.list_all import run as run_list
from mse_cli.cloud.command.localtest import run as run_localtest
from mse_cli.cloud.command.login import run as run_login
from mse_cli.cloud.command.logs import run as run_logs
from mse_cli.cloud.command.scaffold import run as run_scaffold
from mse_cli.cloud.command.status import run as run_status
from mse_cli.cloud.command.stop import run as run_stop
from mse_cli.cloud.command.test import run as run_test
from mse_cli.cloud.command.verify import run as run_verify
from mse_cli.cloud.model.context import Context
from mse_cli.core.conf import AppConf, SSLConf


def _test_verify(
    f,
    domain_name: str,
    fingerprint: str,
    context: Optional[Path],
    code: Optional[Path],
    is_self_signed: bool,
    workspace: Path,
) -> Optional[Path]:
    """Test the verify subcommand."""
    tmp_path = Path(tempfile.mkdtemp(dir=workspace))

    try:
        run_verify(
            Namespace(
                **{
                    "fingerprint": fingerprint,
                    "context": context,
                    "code": code,
                    "domain_name": domain_name,
                    "workspace": tmp_path,
                }
            )
        )
    except Exception as exc:
        if not is_self_signed:
            assert "The application is not using a certificate generated by MSE" in str(
                exc
            )
            return None
        else:
            print(exc)
            assert False

    output = capture_logs(f)
    return re.search("The verified certificate has been saved at: (.+)", output).group(
        1
    )


def _test_scaffold(workspace) -> Path:
    """ "Test the scaffold subcommand."""
    # Generate a random unique app name
    unique_name = str(uuid4())

    # Go into a unique tmp directory
    os.chdir(workspace)

    # Run scaffold
    run_scaffold(Namespace(**{"app_name": unique_name}))

    # Check creation of files
    conf = workspace / unique_name / "mse.toml"
    assert conf.exists()
    assert (workspace / unique_name / "mse_src").exists()

    # The viability (is that runnable?) of the code will be tested later
    return conf


def _test_localtest(f: io.StringIO, conf: Path) -> None:
    """Test the localtest subcommand."""
    run_localtest(Namespace(**{"path": conf, "no_tests": False}))

    assert "Tests successful" in capture_logs(f)


def _test_test(f: io.StringIO, app_id: UUID) -> None:
    """Test the localtest subcommand."""
    run_test(Namespace(**{"app_id": app_id}))

    output = capture_logs(f)


def _test_deploy(
    f: io.StringIO, conf: Path, untrusted_ssl: bool, workspace: Path
) -> Tuple[UUID, str, str]:
    """Test the deploy subcommand."""
    tmp_path = Path(tempfile.mkdtemp(dir=workspace))

    run_deploy(
        Namespace(
            **{
                "path": conf,
                "y": False,
                "no_verify": False,
                "untrusted_ssl": untrusted_ssl,
                "workspace": tmp_path,
                "timeout": 15,
            }
        )
    )

    output = capture_logs(f)

    try:
        app_id = re.search("mse cloud logs ([a-z0-9-]+)", output).group(1)

        # We use this file in the conftest.py in case of failure
        (workspace / "app_id").write_text(str(app_id))

        domain_name = re.search("ready to be used on https://(.+) until", output).group(
            1
        )

        mr_enclave = re.search("The code fingerprint is ([a-z0-9]+)", output).group(1)

    except AttributeError:
        print(output)
        assert False

    return UUID(app_id), domain_name, mr_enclave


def _test_context(f: io.StringIO, app_id: UUID) -> Context:
    """Test the context subcommand."""
    # Check the context directory
    assert Context.get_context_filepath(app_id, create=False).exists()
    assert (
        Context.get_dirpath(app_id, False) / Context.get_tar_code_filename()
    ).exists()

    # Check the context subcommand (listing)
    run_context(
        Namespace(**{"list": True, "remove": False, "purge": False, "export": None})
    )

    output = capture_logs(f)
    assert str(app_id) in output

    # Check the context subcommand (exporting)
    run_context(
        Namespace(**{"list": False, "remove": False, "purge": False, "export": app_id})
    )

    _ = capture_logs(f)
    context_path = Path(f"{app_id}.toml")
    assert context_path.exists()
    return Context.load(context_path)


def _test_status(f: io.StringIO, app_id: UUID, expecting_status: str):
    """Test status subcommand."""
    run_status(Namespace(**{"app_id": app_id}))

    output = capture_logs(f)
    assert expecting_status in output


def _test_login(f: io.StringIO):
    """Test status subcommand."""
    run_login(Namespace(**{"whoami": True}))

    output = capture_logs(f)
    assert "You are currently logged in" in output


def _test_logs(f: io.StringIO, app_id: UUID, expecting_output: str):
    """Test logs subcommand."""
    run_logs(Namespace(**{"app_id": app_id}))

    output = capture_logs(f)
    assert expecting_output in output


def _test_list(f: io.StringIO, project_name: str, app_id: UUID, expecting_result: bool):
    """Test list subcommand."""
    run_list(Namespace(**{"project_name": project_name, "all": False}))

    output = capture_logs(f)
    assert (str(app_id) in output) == expecting_result


def _test_mse_cli(
    workspace: Path,
    f: io.StringIO,
    ssl_certificate_origin: SSLCertificateOrigin,
    untrusted_ssl: bool,
    conf: Optional[Path] = None,
) -> Tuple[Path, str, str]:
    """Test a complete deployment flow."""
    # Test the login subcommand
    _test_login(f)

    # Test the scaffold subcommand
    if conf is None:
        conf = _test_scaffold(workspace)

    app_conf = AppConf.load(conf)

    assert not app_conf.cloud.ssl

    if ssl_certificate_origin == SSLCertificateOrigin.Owner:
        cert_path = workspace / "cert.pem"
        cert_path.write_text(os.getenv("MSE_TEST_PUBLIC_KEY"))
        key_path = workspace / "key.path"
        key_path.write_text(os.getenv("MSE_TEST_PRIVATE_KEY"))

        app_conf.cloud.ssl = SSLConf(
            domain_name=f"{app_conf.name}.{os.getenv('MSE_TEST_DOMAIN_NAME')}",
            private_key=key_path,
            certificate=cert_path,
        )
        app_conf.save(conf)

    # The the localtest subcommand
    _test_localtest(f, conf)

    # Test the deploy subcommand
    (app_id, domain_name, mr_enclave) = _test_deploy(f, conf, untrusted_ssl, workspace)

    # Test the context subcommand
    context = _test_context(f, app_id)

    # Check the ssl type
    if ssl_certificate_origin == SSLCertificateOrigin.Owner and untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Operator
        assert not context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Owner and not untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Owner
        assert context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Self and untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Operator
        assert not context.config.ssl_app_certificate
    elif ssl_certificate_origin == SSLCertificateOrigin.Self and not untrusted_ssl:
        assert context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self
        assert not context.config.ssl_app_certificate

    # Test the verify subcommand
    # Skip MR Enclave computation
    _test_verify(
        f,
        domain_name,
        False,
        None,
        None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
        workspace,
    )
    # Give the MR Enclave
    _test_verify(
        f,
        domain_name,
        mr_enclave,
        None,
        None,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
        workspace,
    )
    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        # Give a bad MR Enclave
        with pytest.raises(Exception):
            tmp_path = Path(tempfile.mkdtemp(dir=workspace))

            run_verify(
                Namespace(
                    **{
                        "fingerprint": "00000000",
                        "context": None,
                        "code": None,
                        "domain_name": domain_name,
                        "workspace": tmp_path,
                    }
                )
            )
        # Compute the MR Enclave (bad code)
        with pytest.raises(Exception):
            tmp_path = Path(tempfile.mkdtemp(dir=workspace))

            run_verify(
                Namespace(
                    **{
                        "fingerprint": None,
                        "context": Context.get_context_filepath(app_id, False),
                        "code": Path("."),
                        "domain_name": domain_name,
                        "workspace": tmp_path,
                    }
                )
            )
    # Compute the MR Enclave
    cert_path = _test_verify(
        f,
        domain_name,
        False,
        Context.get_context_filepath(app_id, False),
        app_conf.cloud.code,
        context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self,
        workspace,
    )

    if context.instance.ssl_certificate_origin == SSLCertificateOrigin.Self:
        assert cert_path is not None
        # Check the url is working with the proper certificate
        r = requests.get(url=f"https://{domain_name}/", verify=cert_path, timeout=10)
    else:
        r = requests.get(url=f"https://{domain_name}/", timeout=10)

    assert r.ok
    assert r.text == "Hello world"

    # Test status subcommand
    _test_status(f, app_id, "running")
    _test_logs(f, app_id, 'GET / HTTP/1.1" 200')

    # Test the test subcommand
    _test_test(f, app_id)

    # Test list subcommand
    _test_list(f, app_conf.cloud.project, app_id, True)

    # Test stop app
    run_stop(Namespace(**{"app_id": [app_id]}))

    # Test status subcommand
    _test_status(f, app_id, "stopped")
    _test_logs(f, app_id, 'GET / HTTP/1.1" 200')

    # Test list subcommand
    _test_list(f, app_conf.cloud.project, app_id, False)

    f.truncate(0)

    # Check the context subcommand
    run_context(
        Namespace(**{"list": True, "remove": False, "purge": False, "export": None})
    )

    output = capture_logs(f)
    assert str(app_id) not in output
    assert not Context.get_dirpath(app_id, False).exists()

    return conf, app_id, domain_name


def reset_conf_ssl_parag(conf: Path):
    """Reset the SSL parag from configuration."""
    app_conf = AppConf.load(conf)
    app_conf.cloud.ssl = None
    app_conf.save(conf)


@pytest.mark.cloud
def test_mse_cli_self_signed(cmd_log, tmp_path):
    """Test a complete deployment flow for dev mode."""
    # Note: we use tmp_path to get a dedicated tmp dir for each tests
    _test_mse_cli(tmp_path, cmd_log, SSLCertificateOrigin.Self, False)


@pytest.mark.cloud
def test_mse_cli_with_ssl(cmd_log, tmp_path):
    """Test a complete deployment flow for dev mode."""
    _test_mse_cli(tmp_path, cmd_log, SSLCertificateOrigin.Owner, False)


@pytest.mark.cloud
def test_mse_cli_self_signed_untrusted(cmd_log, tmp_path):
    """Test a complete deployment flow for untrusted ssl."""
    _test_mse_cli(tmp_path, cmd_log, SSLCertificateOrigin.Self, True)


@pytest.mark.cloud
def test_mse_cli_with_ssl_untrusted(cmd_log, tmp_path):
    """Test a complete deployment flow for untrusted ssl."""
    _test_mse_cli(tmp_path, cmd_log, SSLCertificateOrigin.Owner, True)


@pytest.mark.cloud
def test_mse_cli_appid_self_signed(cmd_log, tmp_path):
    """Test successive `deploy` in self-signed mode."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name == domain_name_2  # domain name does not change


@pytest.mark.cloud
def test_mse_cli_appid_untrusted_ssl(cmd_log, tmp_path):
    """Test successive `deploy` in untrusted SSL mode."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name == domain_name_2  # domain name does not change


@pytest.mark.cloud
def test_mse_cli_ssl_to_ssl(cmd_log, tmp_path):
    """Test successive `deploy` from SSL to SSL."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False
    )

    reset_conf_ssl_parag(conf)

    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name == domain_name_2  # domain name does not change


@pytest.mark.cloud
def test_mse_cli_untrusted_to_self_signed(cmd_log, tmp_path):
    """Test successive `deploy` from untrusted SSL to self-signed."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2


@pytest.mark.cloud
def test_mse_cli_self_signed_to_untrusted(cmd_log, tmp_path):
    """Test successive `deploy` from self-signed to untrusted SSL."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2


@pytest.mark.cloud
def test_mse_cli_ssl_to_self_signed(cmd_log, tmp_path):
    """Test successive `deploy` from SSL to self-signed."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False
    )

    reset_conf_ssl_parag(conf)

    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2


@pytest.mark.cloud
def test_mse_cli_self_signed_to_ssl(cmd_log, tmp_path):
    """Test successive `deploy` from self-signed to SSL."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Self, False
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2


@pytest.mark.cloud
def test_mse_cli_ssl_to_operator(cmd_log, tmp_path):
    """Test successive `deploy` from SSL to untrusted SSL."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False
    )

    reset_conf_ssl_parag(conf)

    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2


@pytest.mark.cloud
def test_mse_cli_untrusted_to_ssl(cmd_log, tmp_path):
    """Test successive `deploy` from untrusted SSL to SSL."""
    conf, app_id, domain_name = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Operator, True
    )
    _, app_id_2, domain_name_2 = _test_mse_cli(
        tmp_path, cmd_log, SSLCertificateOrigin.Owner, False, conf=conf
    )

    assert app_id != app_id_2
    assert domain_name != domain_name_2
